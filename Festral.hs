{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

module Festral (
    curlJobs,
    getJob,
    getJobWhenDone,
    startJob,
    getFileList,
    getJobOutFile,
    getJobOut
) where

import Network.Curl.Aeson
import Network.Curl
import Control.Applicative
import Data.Aeson
import GHC.Generics
import Control.Concurrent
import System.Process
import System.IO
import qualified Data.ByteString.Lazy as LB
import qualified Data.ByteString.Char8 as B
import System.Environment
import Data.List.Split
import Data.List
import Control.Monad

main = do
    args <- getArgs
    runCmd args

runCmd :: [String] -> IO ()

runCmd ["all", "jobs"] = show <$> curlJobs >>= putStrLn

runCmd ["get", "job", y] = do
    let id = read y :: Int
    show <$> getJob id >>= putStrLn

runCmd ["get", "job", "when", "done", y] = do
    let id = read y :: Int
    show <$> getJobWhenDone id >>= putStrLn

runCmd ["start", "job", f] = show <$> startJob f >>= putStrLn

runCmd ["list", "job", "files", id] = show <$> getFileList (read id :: Int) >>= putStrLn

runCmd ["get", "job", "file", id, fname] = getJobOutFile (read id :: Int) fname >>= justPutStrLn "No such job."

runCmd ["get", "job", "stdout", id] = getJobOut (read id :: Int) >>= putStrLn

runCmd _ = do
    pname <- getProgName
    putStrLn $ "Usage: \n" 
                ++ pname ++ " all jobs - list all jobs on weles\n"
                ++ pname ++ " get job <id> - show information about job with given id\n"
                ++ pname ++ " get job when done <id> - like 'get job' but waiting until given job finished\n"
                ++ pname ++ " start job <yamlname> - start job described in 'yamlfile' and returns its id\n" 
                ++ pname ++ " list job files <id> - list all output files created by job with given id>\n" 
                ++ pname ++ " get job file <id> <filename> - get content of the file with <filename> of the jod with given id>\n" 
                ++ pname ++ " get job stdout <id> - get standard out and standard error outputs of the job given by id\n" 

justPutStrLn :: (Show a, Eq a) => String -> Maybe a -> IO ()
justPutStrLn errMsg x
    | x == Nothing = putStrLn errMsg
    | otherwise = let Just y = x in putStrLn $ (read $ show y :: String)

-- |Job datatype describes json job object got from weles
data Job = Job {
    jobid   :: Int
    ,name   :: String
    ,created:: String
    ,updated:: String
    ,status :: String
    ,info   :: String
} deriving (Generic)

instance FromJSON Job 
instance ToJSON Job 
instance Show Job where
    show (Job id n c u s i) = "{\n \"jobid\" : " ++ show id ++ ",\n \"name\" : "
                ++ show n ++ ",\n \"created\" : " 
                ++ show c ++ ",\n \"updated\" : "
                ++ show u ++ ",\n \"status\" : "
                ++ show s ++ ",\n \"info\" : "
                ++ show i ++ "\n}\n"

welesAddr = "127.0.0.1"
welesPort = "5010"
welesFilePort = "8888"

-- |Get list of all jobs on server
curlJobs :: IO [Job]
curlJobs = curlAesonGet (welesAddr ++ ":" ++ welesPort ++ "/api/v1/jobs/")

-- |Get job by its ID
getJob :: Int -> IO (Maybe Job)
getJob id = do
    jobs <- curlJobs
    let job = filter ((id ==) . jobid) jobs
    let res = if length job == 0
                then Nothing
                else Just $ head job
    return res

doneStatuses = ["FAILED", "COMPLETED", "CANCELED"]

-- |Wait until job with given id got status one of 'doneStatuses' and then return this job
getJobWhenDone :: Int -> IO (Maybe Job)
getJobWhenDone id = do
    job <- getJob id
    let res = if (status <$> job) `elem` (map Just doneStatuses)
                then return job
                else threadDelay 1000000 >> getJobWhenDone id
    res

data SimpleJob = SimpleJob {s_jobid :: Int}
    deriving (Show)

instance FromJSON SimpleJob where
    parseJSON = withObject "SimpleJob" $ \v -> SimpleJob <$> v.: "jobid"

-- |Send new job defined in the YAML file with name given as parameter to server
-- Returns id of new task
startJob :: String -> IO (Maybe Int)
startJob yamlFileName = do
    (_, out, err, _) <- runInteractiveCommand (
                        "curl -sL " 
                         ++ welesAddr 
                         ++ ":" 
                         ++ welesPort 
                         ++ "/api/v1/jobs/ -F \"uploadfile=@"
                         ++ yamlFileName
                         ++ ";\""
                      )
    outStr <- hGetContents out
    let sjob = decode (LB.fromStrict $ B.pack outStr) :: Maybe SimpleJob
    putStrLn =<< hGetContents err
    return (s_jobid <$> sjob)

testFileUrl id = welesAddr ++ ":" ++ welesFilePort ++ "/" ++ show id ++ "/TESTFILE/"

-- |Returns list of filenames generated by job with given id. 
-- If job with given id does not exists return Nothing.
getFileList :: Int -> IO (Maybe [String])
getFileList id = do
    (errCode, htmlOut) <- curlGetString (testFileUrl id) [CurlFollowLocation True]
    let res = if errCode == CurlOK
            then Just (extractHrefs htmlOut)
            else Nothing
    return res

    where
        extractHrefs = (map (\x -> x!!1)) . (map (splitOn "\"")) . ((filter (isInfixOf "a href=")) . (splitOneOf "<>"))

-- |Returns just contents of the file with given name located on Weles server
-- for job with given id. If file or job does not exists returns Nothing.
getJobOutFile :: Int -> String -> IO (Maybe String)
getJobOutFile id fname = do
    (errCode, content) <- curlGetString ((testFileUrl id) ++ fname) [CurlFollowLocation True]
    let res = if errCode == CurlOK
            then Just content
            else Nothing
    return res

-- |Returns standard output of job given by id (contents of the results file).
getJobOut :: Int -> IO String
getJobOut id = do
    fnames <- getFileList id
    let resFnames = filter (isInfixOf "results") <$> fnames
    let Just resName = if resFnames == Nothing
            then Just []
            else resFnames
    let contents = map (getJobOutFile id) resName
    concat <$> (liftM concat) <$> (sequence contents)
