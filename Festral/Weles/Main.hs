module Main (
    main
) where

import System.Process
import System.IO
import System.Environment
import Festral.Weles.API
import Options.Applicative
import Data.Semigroup ((<>))
import Festral.Tests.Test
import Festral.Files

main = runCmd =<< execParser options
    where
        options = info ((opts <|> testCtl <|> versionOpt) <**> helper)
            ( fullDesc
            <>progDesc  "Create jobs on remote Weles server with tests defined in .yaml files and process responces with results of its execution."
            <>header    "Festral - simple client for tests management using Weles as test server" )

data Options = JobControl
    { all       :: Bool
    , jobId     :: Int
    , done      :: Int
    , filename  :: FilePath
    , start     :: Bool
    , stdout    :: Bool
    , listFile  :: Bool
    , cancel    :: Bool
    } 
    | None
    | TestControl
    { perfTest  :: FilePath
    , buildPath :: FilePath
    }
    | Version
    { version   :: Bool }

opts :: Parser Options
opts = JobControl
    <$> switch
        ( long  "all"
        <>short 'a'
        <>help  "List all jobs." )
    <*> option auto
        ( long  "job-id"
        <>short 'i'
        <>value (-1)
        <>showDefault
        <>help  "Id of the job to be selected. With no other options list information about this job."
        <>metavar "JOB_ID" )
    <*> option auto
        ( long  "when-done"
        <>short 'd'
        <>metavar "TIME_LIMIT"
        <>value 0
        <>help  "Wait until queried job done before doing rest and until TIME_LIMIT is not is now wasted." )
    <*> strOption
        ( long  "filename"
        <>short 'f'
        <>value ""
        <>metavar "FILENAME"
        <>help  ("Give filename to the program. What to to with "
                ++ "it depends on other selected options.") )
    <*> switch
        ( long  "start-job"
        <>short 's'
        <>help  ("Start new job passing to the Weles yaml file set by -f option. "
                 ++ "Returns id of the created job.") )
    <*> switch
        ( long  "job-stdout"
        <>help  "Print standard output and error streams of job set by -i option." )
    <*> switch
        ( long  "list-files"
        <>help  "List all files generated by job set by -i option. If -f option is set print content of that file if it was created by job." )
    <*> switch
        ( long  "cancel"
        <>short 'c'
        <>help  "Cancel job specified by -i option." )

testCtl :: Parser Options
testCtl = TestControl
    <$> strOption
        ( long  "run-test"
        <>short 'r'
        <>metavar "TEST_CONFIG_FILE"
        <>help  "Run tests listed in TEST_CONFIG_FILE for specified by -f option build directory. Run for all targets listed in '~/.fresh_builds' file if no target specified." )
    <*> strOption
        ( long  "with-build"
        <>short 'b'
        <>metavar "BUILD_DIR"
        <>value ""
        <>help  "Run test only for this build if defined" )

versionOpt :: Parser Options
versionOpt = Version
    <$> switch
        ( long  "version"
        <>short 'v'
        <>help  "Show version of this program." )
    

runCmd :: Options -> IO ()

runCmd (Version True) = putStrLn $ "festral-weles v." ++ progVersion

runCmd (TestControl conf "") = do
    lastTestFile <- freshTests
    writeFile lastTestFile ""

    listFile <- freshBuilds
    list <- readFile listFile
    performForallNewBuilds conf list

runCmd (TestControl config fname) = performTestWithConfig config fname

runCmd (JobControl all id done fname start stdout listFile cancel)
    | all = show <$> curlJobs >>= putStrLn
    | cancel = cancelJob id
    | start = show <$> startJob fname >>= putStrLn
    | listFile && fname == "" = show <$> getFileList id >>= putStrLn
    | listFile = getJobOutFile id fname >>= justPutStrLn "No such job."
    | stdout = getJobOut id >>= putStrLn
    | done == 0 = show <$> getJob id >>= putStrLn
    | id /= (-1) = show <$> getJobWhenDone id done >>= putStrLn
    | otherwise = runCmd None

runCmd _ = putStrLn "Some parameter missed. Run program with --help option to see usage."

justPutStrLn :: (Show a, Eq a) => String -> Maybe a -> IO ()
justPutStrLn errMsg x
    | x == Nothing = putStrLn errMsg
    | otherwise = let Just y = x in putStrLn $ (read $ show y :: String)
